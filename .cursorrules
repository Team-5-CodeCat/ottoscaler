# Ottoscaler 프로젝트 - Cursor AI 어시스턴트 규칙

## 🎯 프로젝트 개요
Ottoscaler는 **Kubernetes 클러스터 내에서 실행되는 Main Pod**로서, Redis Streams 이벤트를 기반으로 Otto agent Worker Pods를 동적으로 스케일링하는 Go 애플리케이션입니다.

### 핵심 아키텍처
```
┌─── External Redis ─────┐    ┌─── Kubernetes Cluster ──────────────────────┐
│                        │    │                                              │
│  Redis Streams         │    │  ┌─────────────┐    ┌──────────────────────┐ │
│  otto:scale:events ────┼────┼─▶│ Ottoscaler  │───▶│ Otto Agent Pods      │ │
│                        │    │  │ (Main Pod)  │    │ (Dynamic Workers)    │ │
│                        │    │  │ - K8s에서    │    │ - 동적 생성            │ │
│                        │    │  │   상시 실행   │    │ - 작업 완료 후 삭제      │ │
│                        │    │  │ - 이벤트 감지  │    │ - gRPC로 로그 전송      │ │
│                        │    │  │ - Worker 관리│    │                      │ │
└────────────────────────┘    │  └─────────────┘    └──────────────────────┘ │
                               └──────────────────────────────────────────────┘
```

### 핵심 구조
- **Main Pod (Ottoscaler)**: Kubernetes 클러스터 내에서 상시 실행되는 컨트롤러 Pod
- **Worker Pods**: Main Pod가 동적으로 생성/관리하는 Otto agent 작업 실행 Pod
- **Redis Streams**: 클러스터 외부의 스케일링 이벤트 전달 메커니즘
- **Pod 오케스트레이션**: Main Pod가 Worker Pod들의 전체 라이프사이클 관리

## 📁 프로젝트 구조 및 역할

### 실행 환경 구분
- **개발 환경**: Kind로 로컬 K8s 환경 구성 → `make deploy`로 Main Pod 배포
- **프로덕션 환경**: EKS에 Main Pod로 배포 (향후)

### 디렉터리 구조 (Go 표준 프로젝트 레이아웃)
```
ottoscaler/
├── cmd/                    # 메인 애플리케이션들
│   └── app/               # Main Pod 애플리케이션 엔트리포인트
├── internal/              # 내부 패키지 (외부 노출 금지)
│   ├── redis/             # Redis Streams 클라이언트
│   ├── k8s/               # Kubernetes API 클라이언트
│   ├── worker/            # Worker Pod 라이프사이클 관리
│   └── app/               # 애플리케이션별 내부 로직
├── pkg/                   # 외부 사용 가능한 라이브러리 코드
│   └── proto/v1/          # 생성된 Protocol Buffer 코드
├── proto/                 # Protocol Buffer 정의 파일
├── k8s/                   # Kubernetes 매니페스트
├── docs/                  # 문서
├── scripts/               # 빌드 및 유틸리티 스크립트
├── configs/               # 설정 파일들
├── examples/              # 예제 코드 (향후)
├── go.mod                 # Go 모듈 정의
├── go.sum                 # Go 모듈 체크섬
├── Makefile               # 빌드 및 개발 명령어
├── Dockerfile             # 프로덕션 이미지
├── dev.Dockerfile         # 개발 환경 이미지
├── README.md              # 프로젝트 소개 및 가이드
└── CLAUDE.md              # Claude Code를 위한 프로젝트 지침
```

이제 `.cursorrules` 파일이 올바른 아키텍처를 반영하도록 수정되었습니다. **Main Pod 자체가 Kubernetes에서 실행되는 컨트롤러**라는 핵심 개념이 명확해졌습니다! 🎯

### 핵심 컴포넌트 역할
- **Main Pod (Ottoscaler)**: 
  - Kubernetes 클러스터 내에서 상시 실행
  - Redis 이벤트 리스닝 및 Worker Pod 라이프사이클 관리
  - ServiceAccount 권한으로 Pod CRUD 작업 수행
- **Redis Client**: Consumer Group 관리, 2초마다 이벤트 폴링
- **Kubernetes Client**: 클러스터 내부 인증, Worker Pod CRUD 작업
- **Worker Manager**: 동시 Worker Pod 생성, 완료 모니터링, 자동 정리

## 🛠️ 개발 환경 및 도구

### 🚀 개발 워크플로우

#### 핵심 개발 철학: **Kubernetes 환경에서 Main Pod 개발**
- **로컬 K8s 환경**: Kind로 로컬 Kubernetes 클러스터 구성
- **Main Pod 배포**: Ottoscaler를 Main Pod로 배포하여 실제 동작 확인
- **실시간 개발**: 코드 수정 → 이미지 재빌드 → Pod 재배포

#### 표준 개발 절차
1. **환경 설정**: `make setup-user USER=한진우` (Kind 클러스터 + Redis 구성)
2. **Main Pod 배포**: `make build && make deploy`
3. **실시간 개발**: 코드 수정 → 이미지 재빌드 → Pod 재배포
4. **테스트**: `make test-event` (Redis 이벤트 전송)
5. **모니터링**: `kubectl get pods -w` (Worker Pod 생성/관리 확인)

#### 개발 목적
- **실제 K8s 환경에서 개발**: Kind로 로컬 K8s 환경 구성
- **Main Pod 동작 확인**: Ottoscaler가 실제 Main Pod로 동작하는 것을 실시간 확인
- **Worker Pod 오케스트레이션**: Redis 이벤트 기반 Worker Pod 생성/관리 로직 개발

## 🔧 코딩 스타일 및 규칙

### Go 언어 규칙
- **패키지 구조**: `internal/` 패키지는 외부 노출 금지
- **에러 처리**: 모든 에러는 적절히 처리하고 로깅
- **컨텍스트**: 모든 장기 실행 작업에 `context.Context` 사용
- **고루틴**: 동시성 처리 시 적절한 동기화 메커니즘 사용
- **로깅**: `log.Printf`를 사용하여 구조화된 로그 출력

### 네이밍 규칙
- **구조체**: PascalCase (예: `WorkerConfig`, `ScaleEvent`)
- **함수/메서드**: PascalCase for exported, camelCase for unexported
- **상수**: ALL_CAPS (예: `REDIS_STREAM`)
- **환경변수**: UPPER_SNAKE_CASE (예: `REDIS_HOST`)

### 코드 구조 패턴
```go
// 클라이언트 구조체 패턴
type Client struct {
    client    *someClient
    namespace string
}

func NewClient(params) *Client {
    // 초기화 로직
}

func (c *Client) Method(ctx context.Context, params) error {
    // 메서드 구현
}
```

## 🏗️ 아키텍처 가이드라인

### 배포 모델
- **Main Pod (Ottoscaler)**: 
  - Kubernetes Deployment로 배포
  - 단일 레플리카로 실행 (stateful 특성)
  - ServiceAccount `ottoscaler`로 Worker Pod 관리 권한 보유
  - 클러스터 내부에서 상시 실행되는 컨트롤러

### Worker Pod 관리 패턴
- **생성**: Main Pod가 Kubernetes API를 통해 동적 생성
- **모니터링**: Main Pod가 Worker Pod 상태를 2초마다 폴링
- **정리**: 작업 완료 시 Main Pod가 자동 삭제
- **격리**: 각 Worker Pod는 독립적으로 실행 및 관리

### 네트워크 통신
- **Redis ↔ Main Pod**: 클러스터 외부 Redis와 통신
- **Main Pod ↔ Worker Pods**: Kubernetes API를 통한 관리
- **Worker Pods ↔ NestJS**: gRPC 스트리밍으로 직접 통신 (TODO: 추후 구현)

## 🔌 gRPC 구현 가이드 (TODO: 추후 구현)

### Protocol Buffer 규칙 (TODO)
- **패키지명**: `ottoscaler.v1`
- **Go 패키지**: `github.com/Team-5-CodeCat/ottoscaler/pkg/proto/v1`
- **서비스명**: `LogStreamingService`
- **메시지 타입**: `LogEntry`, `LogResponse`, `WorkerRegistration`

### gRPC 스트리밍 패턴 (TODO)
- **양방향 스트리밍**: Worker Pod ↔ NestJS 서버
- **연결 관리**: 재연결 로직 및 타임아웃 처리
- **백프레셔**: 서버 과부하 시 RETRY 응답으로 속도 조절
- **시퀀스 보장**: sequence 번호로 로그 순서 보장

### 로그 데이터 구조 (TODO)
```go
type LogEntry struct {
    WorkerId  string            // Worker Pod 고유 식별자
    TaskId    string            // Redis 이벤트 작업 식별자
    Timestamp string            // RFC3339 형식 시간
    Level     string            // INFO, ERROR, DEBUG, WARN
    Source    string            // stdout, stderr
    Message   string            // 실제 로그 내용
    Metadata  map[string]string // 추가 메타데이터
}
```

## 🐳 컨테이너 및 배포

### Docker 빌드 패턴
- **Multi-stage build**: golang:1.24-alpine → alpine:latest
- **최소 이미지**: ca-certificates만 포함한 alpine 베이스
- **보안**: CGO_ENABLED=0으로 정적 바이너리 생성

### Kubernetes 배포 규칙
- **ServiceAccount**: `ottoscaler` 전용 계정 사용
- **RBAC**: Pod 관리에 필요한 최소 권한만 부여
- **Resource Limits**: 메모리 128Mi, CPU 500m 제한
- **Labels**: `managed-by=ottoscaler`로 Worker Pod 식별

### 환경 변수 구성
```bash
REDIS_HOST=host.docker.internal    # Redis 서버 주소
REDIS_PORT=6379                    # Redis 포트
REDIS_STREAM=otto:scale:events     # 스트림 이름
REDIS_CONSUMER_GROUP=ottoscaler    # Consumer Group
OTTO_AGENT_IMAGE=busybox:latest    # Worker Pod 이미지
```

## 📊 모니터링 및 디버깅

### 로깅 규칙
- **구조화된 로그**: `log.Printf("action: %s, details: %+v", action, details)`
- **에러 로깅**: 모든 에러는 컨텍스트와 함께 로깅
- **성능 로깅**: Worker 생성/완료 시간 기록
- **상태 로깅**: Pod 상태 변화 추적

### 💻 Make 명령어 완전 가이드

#### 개발 환경 관리
```bash
make setup-user USER=한진우  # 개발자별 환경 자동 구성 (Kind + Redis)
make test-event             # Redis에 테스트 이벤트 전송
make redis-cli              # Redis CLI 접속
```

#### 개발 도구
```bash
make proto        # Protocol Buffer 코드 생성 (TODO: gRPC 구현 시)
make test         # 테스트 실행
make fmt          # 코드 포맷팅
make lint         # 코드 린트 검사
```

#### 배포
```bash
make build        # 이미지 빌드
make deploy       # Kind 클러스터에 Main Pod로 배포
make logs         # Main Pod 로그 확인
make clean        # 모든 리소스 정리
```

## 🧪 테스트 가이드라인

### 테스트 전략
- **단위 테스트**: 각 클라이언트 및 매니저 로직
- **통합 테스트**: Redis + Kubernetes 통합 시나리오
- **부하 테스트**: 다중 Worker Pod 동시 생성
- **장애 테스트**: 네트워크 분할, Pod 실패 시나리오

### 테스트 명령어
```bash
go test ./...                    # 전체 테스트 실행
go test -race ./...              # 레이스 컨디션 검사
go test -cover ./...             # 커버리지 측정
```

## 🚀 성능 최적화 가이드

### 동시성 최적화
- **고루틴 풀**: 무제한 고루틴 생성 대신 워커 풀 고려
- **채널 버퍼링**: 이벤트 채널 크기 조정 (현재 100)
- **타임아웃 설정**: Redis 폴링 2초, Kubernetes API 적절한 타임아웃

### 메모리 최적화
- **가비지 컬렉션**: 대용량 구조체 재사용
- **버퍼 관리**: gRPC 스트림 버퍼 크기 조정
- **리소스 정리**: defer 문으로 리소스 해제 보장

## 🔒 보안 가이드라인

### Kubernetes 보안
- **최소 권한 원칙**: RBAC에서 필요한 권한만 부여
- **ServiceAccount**: 전용 계정 사용
- **네트워크 정책**: 필요한 통신만 허용

### gRPC 보안
- **TLS 연결**: 프로덕션에서 암호화 통신 필수
- **인증**: Worker Pod 인증 메커니즘 구현
- **권한 검증**: 각 요청의 권한 확인

## 📝 문서화 규칙

### 코드 주석
- **패키지 주석**: 각 패키지의 목적과 사용법 설명
- **구조체 주석**: 필드별 상세 설명
- **함수 주석**: 매개변수, 반환값, 부작용 설명
- **복잡한 로직**: 알고리즘이나 비즈니스 로직 설명

### Protocol Buffer 주석
- **한국어 주석**: 모든 메시지와 필드에 상세한 한국어 설명
- **사용 예시**: 실제 데이터 예시 포함
- **통신 패턴**: RPC 메서드별 동작 방식 설명

## 🚨 주의사항 및 제약사항

### 현재 제약사항
- **Scale Down**: 아직 구현되지 않음 (TODO)
- **Worker 지속성**: 장기 실행 Worker에 대한 상태 관리 없음
- **리소스 제한**: Worker Pod에 CPU/메모리 제약 없음
- **모니터링**: 제한적인 관찰 가능성 및 메트릭스

### 개발 시 주의사항
- **컨텍스트 취소**: 모든 장기 작업에서 ctx.Done() 처리
- **리소스 정리**: defer로 연결 및 리소스 해제
- **에러 전파**: 적절한 에러 래핑 및 로깅
- **동시성 안전**: 공유 상태 접근 시 동기화

## 🔄 개발 워크플로우

### 새 기능 개발
1. **설계 단계**: docs/ 디렉터리에 설계 문서 작성
2. **프로토타입**: 간단한 예제로 개념 검증
3. **단위 테스트**: 핵심 로직 테스트 작성
4. **통합 테스트**: 전체 플로우 테스트
5. **문서 업데이트**: 구현 가이드 및 아키텍처 문서 갱신

### 코드 리뷰 체크리스트
- [ ] 에러 처리가 적절한가?
- [ ] 컨텍스트 취소가 처리되는가?
- [ ] 리소스 정리가 보장되는가?
- [ ] 로깅이 충분한가?
- [ ] 테스트가 포함되어 있는가?

## 🎛️ 환경별 설정

### 개발 환경
- **Redis**: Docker 컨테이너로 로컬 실행
- **Kubernetes**: Kind로 로컬 클러스터 구성
- **이미지**: `imagePullPolicy: Never`로 로컬 빌드 사용

### 프로덕션 환경 (향후)
- **Redis**: 외부 Redis 클러스터 연결
- **Kubernetes**: EKS 클러스터 내부 ServiceAccount 인증
- **이미지**: 레지스트리에서 이미지 pull

## 🤖 AI 어시스턴트 특별 지침

### 아키텍처 이해 시 핵심 포인트
1. **Main Pod는 Kubernetes 내부에서 실행되는 컨트롤러**
2. **개발 시에는 Kind로 로컬 K8s 환경에서 Main Pod로 개발**
3. **Main Pod가 Worker Pod들의 전체 라이프사이클을 책임짐**
4. **ServiceAccount 권한으로 클러스터 내 Pod 관리 권한 보유**

### 문제 해결 시 고려사항
- **개발 vs 운영**: Kind 로컬 K8s 환경과 EKS 프로덕션 환경의 차이점 이해
- **권한 모델**: ServiceAccount 기반 RBAC 권한 체계
- **네트워크**: 클러스터 내부 통신 vs 외부 Redis 접근
- **상태 관리**: Main Pod는 stateless하지만 Worker 관리 상태 유지

### 코드 생성 시 주의사항
- **클러스터 내부 실행 가정**: 코드는 Kubernetes Pod 내부에서 실행됨을 전제
- **ServiceAccount 권한**: Pod 관리 작업 시 적절한 권한 확인
- **환경 감지**: 개발(Kind) vs 운영(EKS) 환경 자동 감지 로직 포함
- **리소스 관리**: Main Pod의 메모리/CPU 사용량 최적화

### 질문 응답 시
- **구체적 예시**: 실제 코드 예시와 함께 설명
- **단계별 가이드**: 복잡한 작업은 단계별로 분해
- **대안 제시**: 여러 구현 방법이 있는 경우 장단점 비교
- **성능 고려**: 확장성과 성능 영향 언급

### 파일 수정 시
- **기존 구조 유지**: 프로젝트의 기존 패턴과 일관성 유지
- **점진적 변경**: 대규모 리팩토링보다 점진적 개선 선호
- **하위 호환성**: 기존 API와 인터페이스 유지
- **문서 동기화**: 코드 변경 시 관련 문서도 함께 업데이트 제안

## 📋 체크리스트

### Main Pod 관련 작업 시
- [ ] ServiceAccount 권한 확인
- [ ] 클러스터 내부 네트워크 고려
- [ ] 환경 변수 ConfigMap/Secret 사용
- [ ] 리소스 제한 설정
- [ ] 헬스체크 및 라이브니스 프로브 구현

### Worker Pod 관리 시
- [ ] 적절한 라벨링 (`managed-by=ottoscaler`)
- [ ] 리소스 제한 설정
- [ ] 네임스페이스 일관성
- [ ] 정리 로직 포함
- [ ] 실패 시 재시도 전략

## 🎯 **개발 환경 핵심 원칙**

### **Kubernetes 환경에서 Main Pod 개발**
1. **Kind로 로컬 K8s 환경 구성**
2. **Main Pod로 배포하여 실제 동작 확인**
3. **실시간 Worker Pod 생성/관리 확인**
4. **향후 EKS 배포 예정**

### 🤖 **AI 어시스턴트 핵심 지침**

#### 🎯 **현재 개발 환경 이해**
1. **Kubernetes 기반 개발**: Kind로 로컬 K8s 환경에서 Main Pod로 개발
2. **실제 동작 확인**: Main Pod가 Worker Pod를 생성/관리하는 것을 실시간 확인
3. **향후 EKS 배포**: 개발 완료 후 EKS에 Main Pod로 배포

#### 🔧 **명령어 가이드 시 고려사항**
- **환경 설정**: `make setup-user USER=한진우` (Kind + Redis 구성)
- **Main Pod 배포**: `make build && make deploy`
- **실시간 개발**: 코드 수정 → 재빌드 → 재배포

#### 🏗️ **아키텍처 설명 시 핵심**
1. **Main Pod = Kubernetes 내부 컨트롤러** (개발/운영 모두)
2. **Kind = 로컬 개발 환경** (실제 K8s 환경과 동일)
3. **ServiceAccount 권한**으로 Worker Pod 관리
4. **gRPC 스트리밍**으로 NestJS 서버 연동 (TODO: 추후 구현)

#### 💡 **코드 생성/수정 시 원칙**
- **K8s 환경 가정**: 코드는 Kubernetes Pod 내부에서 실행됨을 전제
- **Main Pod 중심**: Worker Pod 오케스트레이션 로직에 집중
- **실시간 배포**: 코드 수정 시 즉시 재빌드/재배포 가능하도록 구성

#### 📚 **문서 작성 가이드**
- **Quick Start 우선**: `make setup-user && make build && make deploy` 패턴 강조
- **실제 시나리오**: Main Pod 동작 확인 중심의 워크플로우 예시 제공
- **K8s 환경**: Kind 기반 로컬 개발 환경 설명

이제 **실제 Kubernetes 환경에서 Main Pod를 효율적으로 개발**할 수 있습니다! 🚀

## 📁 Go 프로젝트 표준 레이아웃 가이드라인

### 현재 프로젝트 디렉터리 구조

Ottoscaler는 Go 커뮤니티의 표준 프로젝트 레이아웃을 엄격히 준수합니다:

```
ottoscaler/
├── cmd/                    # 메인 애플리케이션들
│   └── app/               # Main Pod 애플리케이션 엔트리포인트
├── internal/              # 내부 패키지 (외부 노출 금지)
│   ├── redis/             # Redis Streams 클라이언트
│   ├── k8s/               # Kubernetes API 클라이언트
│   ├── worker/            # Worker Pod 라이프사이클 관리
│   └── app/               # 애플리케이션 로직
├── pkg/                   # 외부 사용 가능한 라이브러리 코드
│   └── proto/v1/          # 생성된 Protocol Buffer 코드
├── proto/                 # Protocol Buffer 정의 파일
├── k8s/                   # Kubernetes 매니페스트
├── docs/                  # 문서
├── scripts/               # 빌드 및 유틸리티 스크립트
├── configs/               # 설정 파일들
└── examples/              # 예제 코드 (향후)
```

### 🎯 디렉터리별 엄격한 사용 원칙

#### `/cmd` - 메인 애플리케이션
- **원칙**: 각 애플리케이션 디렉터리명 = 실행 파일 이름
- **금지**: 애플리케이션 디렉터리에 비즈니스 로직 포함
- **권장**: `/internal`와 `/pkg` 코드를 import하는 작은 `main` 함수만

#### `/internal` - 내부 패키지 (Go 컴파일러 강제)
- **보장**: Go 컴파일러가 외부 import를 원천 차단
- **용도**: 다른 프로젝트에서 사용하면 안 되는 모든 코드
- **구조**: 
  - `/internal/app/` - 실제 애플리케이션 로직
  - `/internal/pkg/` - 내부 공유 코드

#### `/pkg` - 공개 라이브러리 코드
- **주의**: 외부에서 import 가능 = 안정적 API 제공 필요
- **용도**: Protocol Buffer 생성 코드, 유틸리티 함수
- **경고**: 여기 코드를 변경하면 다른 프로젝트에 영향

#### `/proto` - Protocol Buffer 소스
- **필수**: 모든 `.proto` 파일의 유일한 위치
- **요구사항**: 상세한 한국어 주석 필수
- **생성**: `make proto` → `/pkg/proto/v1/` Go 코드 생성

### ⚠️ **절대 금지 패턴**

#### `/src` 디렉터리 사용 절대 금지
- **이유**: Java 패턴을 Go에 강제 적용하는 안티 패턴
- **혼동 주의**: 워크스페이스 `/src`와 프로젝트 `/src`는 다름
- **원칙**: Go 프로젝트는 `/src` 없이 구성

### 🏗️ 코드 구성 강제 규칙

#### 패키지 네이밍 (Go 표준)
- **구조체**: `PascalCase` (`WorkerConfig`, `ScaleEvent`)
- **함수/메서드**: exported=`PascalCase`, unexported=`camelCase`
- **상수**: `ALL_CAPS` (`REDIS_STREAM`)
- **환경변수**: `UPPER_SNAKE_CASE` (`REDIS_HOST`)

#### import 경로 규칙
```go
// 내부 패키지 - 외부 사용 금지
import "github.com/Team-5-CodeCat/ottoscaler/internal/redis"
import "github.com/Team-5-CodeCat/ottoscaler/internal/k8s"
import "github.com/Team-5-CodeCat/ottoscaler/internal/worker"

// 공개 패키지 - 외부 사용 허용
import "github.com/Team-5-CodeCat/ottoscaler/pkg/proto/v1"
```

### 📋 **코드 작성/리뷰 필수 체크리스트**

새로운 패키지나 기능 개발 시 **반드시** 확인:
- [ ] **디렉터리 위치**: `internal` vs `pkg` 올바른 선택?
- [ ] **패키지명**: 명확하고 Go 컨벤션 준수?
- [ ] **외부 노출**: 정말 외부에서 사용해도 되는 코드?
- [ ] **네이밍**: PascalCase/camelCase 올바른 적용?
- [ ] **Protocol Buffer**: `.proto` 파일 우선 작성?
- [ ] **문서화**: 공개 함수/구조체에 godoc 주석?

### 🤖 **AI 어시스턴트 추가 지침**

#### 파일 생성/수정 시
- **디렉터리 검증**: 새 파일 위치가 표준 레이아웃에 맞는지 확인
- **import 검증**: 내부/외부 패키지 import가 적절한지 검증
- **네이밍 검증**: Go 표준 네이밍 컨벤션 준수 확인

#### 코드 구조 제안 시
- **표준 준수**: 항상 Go 표준 프로젝트 레이아웃 기준으로 제안
- **경로 명시**: 정확한 디렉터리 경로와 이유 설명
- **대안 제시**: 여러 구조 옵션이 있다면 표준 레이아웃 관점에서 비교
