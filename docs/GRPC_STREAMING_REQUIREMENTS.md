# gRPC 스트리밍 요구사항

## 개요

Worker Pod에서 실행되는 작업의 모든 로그를 실시간으로 NestJS 백엔드 서버로 전송하는 gRPC 스트리밍 시스템 구현.

## 🎯 요구사항

### 핵심 기능
- Worker Pod의 stdout/stderr 로그를 실시간 수집
- gRPC 스트림을 통해 직접 NestJS 서버로 전송
- 시간 정보와 로그 내용 포함
- Main Pod는 Worker 라이프사이클 관리만 담당

### 데이터 흐름
```
┌─────────────┐         gRPC Stream          ┌─────────────┐
│ Worker Pod  │─────────────────────────────▶│ NestJS      │
│             │                             │ Server      │
│ - stdout    │                             │ (Main       │
│ - stderr    │                             │  Server)    │
│ - timestamp │                             │ - Log       │
│ - task logs │                             │   Processing│
└─────────────┘                             └─────────────┘

┌─────────────┐
│ Main Pod    │  ← Redis Events (별도 역할)
│ (Ottoscaler)│  
│ - Worker    │  
│   Lifecycle │  
│   Management│  
└─────────────┘
```

## 🤔 **아키텍처 질문 (중요한 검토사항)**

### 직접 통신의 장점
1. **단순성**: 관심사의 명확한 분리
2. **성능**: 직접 연결로 중간 릴레이 없음
3. **확장성**: 각 Worker가 독립적으로 스트리밍
4. **장애 격리**: Main Pod 문제가 로그 스트리밍에 영향 없음
5. **리소스 효율성**: Main Pod의 추가 처리 오버헤드 없음

### 설계 고려사항
1. **서비스 디스커버리**: Worker Pod들이 NestJS 서버 엔드포인트를 어떻게 찾는가?
2. **인증**: Worker Pod들이 NestJS와 어떻게 인증하는가?
3. **네트워크 정책**: Worker Pod가 외부 NestJS에 접근할 수 있도록 보장
4. **연결 관리**: 재연결 및 실패 처리
5. **로드 밸런싱**: 여러 NestJS 인스턴스가 존재하는 경우

## 📊 **로그 데이터 구조**

### 예상 로그 엔트리
```json
{
  "timestamp": "2025-09-01T12:34:56.789Z",
  "worker_id": "otto-agent-1-1756659123",
  "task_id": "task-456", 
  "level": "INFO|ERROR|DEBUG",
  "source": "stdout|stderr",
  "message": "Worker task completed successfully",
  "metadata": {
    "pod_name": "otto-agent-1-1756659123",
    "namespace": "default",
    "node": "worker-node-1"
  }
}
```

## 🔧 **기술적 고려사항**

### gRPC 스트림 특성
- **양방향 스트리밍**: Worker가 지속적으로 로그 전송 가능
- **연결 관리**: 연결 끊김 및 재연결 처리
- **백프레셔**: 느린 소비자(NestJS 서버) 처리
- **인증**: 안전한 Worker → Main Pod 통신

### 성능 영향
- **동시 스트림**: Main Pod가 여러 Worker 스트림을 동시에 처리
- **메모리 사용량**: 네트워크 문제 시 로그 버퍼링
- **CPU 오버헤드**: 로그 메시지의 직렬화/역직렬화
- **네트워크 대역폭**: 잠재적으로 큰 로그 데이터 볼륨

### 실패 시나리오
1. **Worker Pod 종료**: gRPC 연결 손실, 부분 로그를 어떻게 처리?
2. **Main Pod 재시작**: 모든 Worker 연결 손실, 재연결 전략?
3. **NestJS 서버 다운**: 로그 버퍼링 vs 드롭 전략?
4. **네트워크 분할**: 얼마나 오래 버퍼링? 언제 포기?

## 🚨 **해결해야 할 중요한 질문들**

### 비즈니스 요구사항
1. **왜 실시간인가?**: 실시간 로그 스트리밍이 필요한 구체적인 비즈니스 니즈는?
2. **볼륨 추정**: Worker Pod 수 × 로그 빈도 × 메시지 크기는?
3. **보존 정책**: 로그를 얼마나 오래 보관? 영구 저장소는 어디?

### 기술적 요구사항  
1. **지연시간**: 로그 전달의 허용 가능한 지연시간은?
2. **신뢰성**: 일부 로그 손실 허용? 아니면 100% 신뢰성 필요?
3. **확장성**: 예상되는 최대 동시 Worker 수와 로그 볼륨은?

### 통합 요구사항
1. **NestJS 엔드포인트**: NestJS 서버가 기대하는 정확한 API는?
2. **인증**: Worker Pod들이 Main Pod와 어떻게 인증해야 하나?
3. **에러 처리**: gRPC 호출 실패 시 어떻게 할 것인가?

## 📋 **구현 계획 (진행하는 경우)**

### 1단계: gRPC 프로토콜 정의
- [ ] 로그 스트리밍용 `.proto` 파일 정의
- [ ] Go 및 TypeScript 코드 생성
- [ ] 메시지 스키마 설계

### 2단계: Main Pod gRPC 서버
- [ ] Main Pod에서 gRPC 서버 구현
- [ ] 다중 동시 스트림 처리
- [ ] 스트림 관리 및 정리 추가

### 3단계: Worker Pod 로그 수집
- [ ] Worker Pod들이 로그를 수집하도록 수정
- [ ] Worker에서 gRPC 클라이언트 구현
- [ ] 연결 관리 및 재시도 로직 추가

### 4단계: NestJS 통합
- [ ] Main Pod에서 gRPC 클라이언트 구현
- [ ] NestJS 서버로 로그 전달
- [ ] 백프레셔 및 실패 처리

### 5단계: 테스트 및 모니터링
- [ ] 다중 Worker로 부하 테스트
- [ ] 실패 시나리오 테스트
- [ ] 성능 모니터링 및 최적화

## ⚠️ **권장사항**

### 구현 전에
1. **비즈니스 필요성 검증**: 실시간 스트리밍이 실제로 필요한지 확인
2. **대안 평가**: Kubernetes 네이티브 로깅 솔루션 고려
3. **용량 계획**: 리소스 요구사항과 비용 추정
4. **프로토타입**: 먼저 간단한 개념 증명 구축

### 진행하는 경우
1. **단순하게 시작**: 고급 기능 없이 기본 gRPC 스트리밍부터
2. **모든 것을 측정**: 성능 모니터링을 위한 메트릭 추가
3. **확장 계획**: 첫날부터 수평 확장을 위한 설계
4. **우아한 성능 저하**: 스트리밍 실패해도 시스템이 작동해야 함

## 🔍 **명확화 필요한 질문들**

1. NestJS 서버가 Kubernetes 클러스터 내부에 있나 외부에 있나?
2. 실시간 로그 스트리밍이 해결하는 구체적인 비즈니스 문제는?
3. 기존 로그 수집 도구(Fluentd, Logstash) 사용을 고려했나?
4. 예상되는 로그 볼륨은? (초당 메시지 수, 총 데이터 크기)
5. 100% 로그 전달이 중요한가 vs 최선 노력 전달로 충분한가?

---

**참고**: 이 문서는 요청된 기능을 나타내지만 필요성과 구현 복잡성에 대한 중요한 질문들을 포함합니다. 전체 구현을 진행하기 전에 더 간단한 대안을 고려해보세요.